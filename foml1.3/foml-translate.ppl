%%% FOML Input to output syntax translation file

class(?c, ?mod):Class(?mod) :- class(?c):Class@?mod;
class(?c, ?mod)::class(?c1, ?mod) :- class(?c)::class(?c1)@?mod;
?p.classes(class(?source, ?mod), ?l, ?h)[class(?target, ?mod)] :- ?p.classes(class(?source), ?l, ?h)[class(?target)]@?mod;
?p.classes(class(?source, ?mod), ?l, ?h)[class(?target, ?mod)] :- ?a.prop(?p, ?l, ?h)[class(?target)]@?mod,
                                                                  ?a.prop(?p1, ?, ?)[class(?source)]@?mod,
                                                                  ?p != ?p1;
?a.ext_assoc(?mod)[true] :- ?a.assoc(?)[?]@?mod;
association(?prop, ?prop1).ext_assoc(?mod)[false] :- ?prop.inverse[?prop1]@?mod;

?p.inverse(?mod)[?p1] :- ?a.prop(?p, ?, ?)[?]@?mod,
                         ?a.prop(?p1, ?, ?)[?]@?mod,
                         ?p != ?p1;
?p.inverse(?mod)[?p1] :- ?p.inverse[?p1]@?mod;

?a.prop(?p, ?l, ?h)[class(?target, ?mod)] :- ?a.prop(?p, ?l, ?h)[class(?target)]@?mod;

?a.assoc([?prop, ?min, ?max, ?tar], ?mod)[[?prop1, ?min1, ?max1, ?tar1]] :- ?a.assoc([?prop, ?min, ?max, ?tar])[[?prop1, ?min1, ?max1, ?tar1]]@?mod;

?mod.isnode[node(?n)] :- ?n:Class(?mod);
?mod.isedge[edge(?from, ?e, ?to)] :- ?e:Property(?mod), ?e.source[?from], ?e.target[?to];
class(?c, ?mod).attr(?a)[?val] :- class(?c).attr(?a)[?val]@?mod;

object(?o, ?mod):class(?c, ?mod) :- object(?o):class(?c)@?mod;
object(?o, ?mod).link(?l)[object(?o1, ?mod)] :- object(?o).link(?l)[object(?o1)]@?mod;
object(?o, ?mod).attr(?a)[?val] :- object(?o).attr(?a)[?val]@?mod;

class(?c, ?mod).func(?f)[?type] :- class(?c).func(?f)[?type]@?mod;
